---
title: "Quel effet \xE7a fait"
description:
url: https://misterpingouin.blogspot.com/2010/02/quel-effet-ca-fait.html
date: 2010-02-08T19:04:00-00:00
preview_image:
authors:
- mrpingouin
source:
---

Quelle différence entre <code>a→b→c</code> et <code>a→b→c</code>? Pour le savoir, lisez ce qui suit.<br><br>De temps en temps, je regarde un article scientifique, ou un bout de code, et je n'en suis pas satisfait. Un truc me chiffonne, ça peut se réparer, mais ya autre chose qui cloche, et au fond c'est tout bancal, ça n'en finit pas, et il vaut mieux tout remettre à plat. Ceci est arrivé récemment dans liquidsoap avec le module de décodage de fichier. Ce n'est pas intéressant de détailler, il y a juste un point dont je voulais parler. Mais avant, je trouve que c'est important de dire qu'il faut remettre les choses à plat de temps en temps.<br><br>Donc, il s'agit de décodage. Première question: qu'est ce que c'est un décodeur? J'ai mis un peu de temps à essayer plusieurs styles, pour finalement décider <code>input -&gt; buffer -&gt; unit</code>, une fonction qui prend en entrée une méthode pour lire des données, et un buffer pour écrire le résultat du décodage, et qui ne renvoie rien mais remplit le buffer un peu plus à chaque fois qu'on l'appelle.<br><br>A côté de cette notion très générique on a des notions plus spécialisées comme le <code>type file_decoder = { fill : Frame.t -&gt; unit ; close : unit -&gt; unit }</code>. C'est un enregistrement qui contient une fonction de remplissage de flux (on lui donne une frame (un morceau de flux) à remplir) et une fonction de fermeture/nettoyage où l'on libère les ressources allouées pour le décodage.<br><br>Ceci étant décidé, j'écris un bout de code générique qui emballe un décodeur pour construire un décodeur_de_fichier:<pre>let file_decoder filename decoder =<br>  let input = input_from_file filename in<br>  let buffer = create_buffer () in<br>  let fill frame =<br>    while not_enough_data_in buffer do<br>      decoder input buffer<br>    done ;<br>    fill_frame_from_buffer frame buffer<br>  in<br>    { fill = fill ; close = fun () -&gt; close input }<br></pre><br>Vous me suivez? Maintenant, j'implémente un décodeur, pour le format MP3 en utilisant la bibliothèque mad:<pre>let create_decoder input =<br>  let resampler = create_resampler () in<br>  let mad_stream = Mad.openstream input in<br>    (fun buffer -&gt;<br>       let data = Mad.decode_frame_float mad_stream in<br>       let sample_freq,_,_ = Mad.get_output_format fd in<br>       let content,length =<br>         resampler ~audio_src_rate:(float sample_freq) data<br>       in<br>         put_audio_in_buffer buffer content length)<br></pre><br>PAF! Vous voyez le bug? Je parie que non, en tout cas moi je l'avais raté. J'ai réussi à ne pas être d'accord avec moi même, penser <code>a→b→c</code> ici et <code>a→b→c</code> là!...<br><br>Le problème, c'est <em>les effets</em>. En mathématiques, une fonction prend un argument et renvoie un résultat. On ne sait pas comment ça se passe "dedans", en tout cas ça n'interagit pas sur le "dehors", et ça se passe pareil à chaque fois: même entrée, même sortie. En informatique, c'est bien plus compliqué. La fonction interagit avec le monde, elle peut afficher quelquechose à l'écran, elle peut aller chercher un résultat sur internet, dans un fichier, ou simplement dans une case mémoire qu'elle partage avec d'autres fonctions. On est ainsi habitué à avoir tout un paquet de fonctions de type <code>a→b</code>, puisqu'il ne s'agit pas seulement de prendre un objet de type <code>a</code> pour calculer un objet de type <code>b</code> mais aussi potentiellement de se livrer à tout un tas d'interactions avec le monde.<br><br>Mon code utilise cela, mais se prend les pieds dedans. Ce qui est joli, c'est que j'ai une "solution". Mais voyons d'abord le problème. Notre décodeur prend un canal d'entrée (<code>input</code>), un canal de sortie (<code>buffer</code>), et est supposé avoir comme <em>effet</em> de lire un peu de données en entrée, de les convertir et les écrire en sortie. Il ne renvoie rien d'utile (<code>unit</code>), tout son interet réside dans l'effet; si on l'appelle un assez grand nombre de fois, on finit par avoir assez de données dans notre buffer -- c'est ce qu'on a fait plus haut. On peut cacher un certains nombres d'informations dans le décodeur, c'était mon intention, par exemple j'y ai alloué un <em>resampler</em> pour convertir les données vers la bonne fréquence d'échantillonage: cet outil doit être (et est bien) crée une fois et une seule pour chaque décodeur.<br><br>Ce resampler maintient un état interne, tout comme le décodeur mad (<code>mad_stream</code>). Allouer ces objets est aussi un effet! Mais à quel moment a-t-il lieu? Le type ne l'indique pas: dans <code>input-&gt;buffer-&gt;unit</code>, après quel argument un effet peut-il avoir lieu? Dans le code de <code>file_decoder</code> j'utilise un décodeur comme si le seul effet était le décodage, qui a lieu une fois qu'on a renseigné l'input et l'output. Mais dans le code du décodeur MP3, pas le choix, je m'autorise un effet entre le moment où on m'a donné l'input et le moment où on me donne le décodeur. Résultat, quand on utilise <code>file_decoder</code> avec le <code>create_decoder</code> MP3, on a un son tout haché, car le décodeur et le resampleur sont reinitialisés sans arrêt, ce qui provoque la perte d'une partie des données mémorisées dans leurs buffers internes.<br><br>Ces problèmes sont très vicieux, et sont toujours un sujet de recherche active. Mais concrètement, que peut-on y faire avec les outils d'aujourd'hui? Documenter, espérer que tout le monde se comprend? Pas terrible, j'ai réussi à être en désaccord avec moi-même sur une courte période de temps. Comme d'habitude, <em>ce serait bien si le système de type nous servait de garde fou</em>.<br><br>En logique, la notion de focalisation (<em>focusing</em>) est liée à la question des effets. Une formule logique est vue comme un jeu entre deux joueurs: un qui prouve l'autre qui réfute, ou encore, l'environnement qui fournit une entrée (argument) et la machine qui renvoie une sortie (valeur de retour). Les connecteurs logiques sont attribués à l'un ou à l'autre joueur: dans <code>(int*int)→(int*int)</code> c'est d'abord l'environnement qui donne un argument, directement composé de deux entiers; puis la machine calcule un résultat, directement composé de deux entiers. Ici je dis directement, car on ne peut pas demander une réponse partielle à la machine, tout ceci vient d'un coup, une unique réponse à une seule question. La dynamique associée au type <code>int→int→(int*int)</code> est exactement la même: il n'y a pas deux questions à l'environnement, mais une seule, les deux entiers en entrée arrivent d'un coup. Là dedans, les seuls effets ne peuvent donc se situer qu'à l'interface entre les deux joueurs, dans le calcul qui se passe entre une question et une réponse.<br><br>Commençons à redescendons sur terre. Pour introduire la possibilité d'un effet, en focalisation, on peut introduire un délai. Par exemple, si on veut une paire d'entiers paresseuse (dont le contenu n'est calculé que si nécessaire), on retarde le calcul des <code>int</code>: <code>(unit-&gt;int)*(unit-&gt;int)</code>. Dans l'autre sens, on peut aussi vouloir retarder le moment où un argument est passé, par exemple avec <code>a-&gt;(unit*(b-&gt;c))</code>... c'est ce qu'il nous faut!<br><br>On la refait avec un délai autour du décodeur, implémenté non pas comme <code>(unit*...)</code> mais plus agréablement avec un type variant:<pre>type decoder = Decoder of (buffer -&gt; unit)<br>type file_decoder = input -&gt; decoder<br><br>let file_decoder filename decoder =<br>  let input = input_from_file filename in<br>  let buffer = create_buffer () in<br>  let Decoder f = decoder input in<br>  let fill frame =<br>    while not_enough_data_in buffer do<br>      f buffer<br>    done ;<br>    fill_frame_from_buffer frame buffer<br>  in<br>    { fill = fill ; close = fun () -&gt; close input }<br><br>let create_decoder input =<br>  let resampler = create_resampler () in<br>  let mad_stream = Mad.openstream input in<br>    Decoder (fun buffer -&gt;<br>       let data = Mad.decode_frame_float mad_stream in<br>       let sample_freq,_,_ = Mad.get_output_format fd in<br>       let content,length =<br>         resampler ~audio_src_rate:(float sample_freq) data<br>       in<br>         put_audio_in_buffer buffer content length)<br></pre><br>Le code du décodeur MP3 n'a changé que d'un iota, mais cela suffit à forcer sa bonne utilisation dans <code>file_decoder</code>, c'est à dire à passer l'input une fois pour toute, et ne plus passer que le buffer dans les appels suivants. Vraiment? Non, à vrai dire, on peut toujours se prendre les pieds dedans, ne serait-ce que parce que c'est possible de traduire entre le vieux type de décodeur et le nouveau, en violant ainsi la logique qu'on a tenté de forcer. Mais en pratique, ce petit garde fou pousse à faire naturellement la bonne chose, ou au moins à se poser la question.<br><br>Tout est bien qui fini bien. Cette histoire pourrait aussi s'intituler "à quoi diable pourrait bien servir un type variant avec un seul constructeur?" Ou encore, "c'est fou comme de belles idées théoriques ont du sens même en dehors de leur strict cadre théorique."
