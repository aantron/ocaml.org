---
title: Enigmes
description:
url: https://misterpingouin.blogspot.com/2007/11/enigme.html
date: 2007-11-21T14:33:00-00:00
preview_image:
authors:
- mrpingouin
source:
---

Quand on pose une énigme mathématique, à moitié formalisée, on finit toujours par avoir une réponse type: "on enlève le bandeau qu'on a sur les yeux", "on casse la gueule au bourreau", etc. D'où l'idée de formaliser vraiment, sous forme d'un exercice de programmation... (qui a dit "maniaque" ?)<br><br>Un groupe de <code>n</code> prisonniers se trouve en mauvaise posture. Ils vont être mis en file indienne, chaque prisonnier voyant seulement les prisonniers devant lui. Puis on leur mettra sur la tête un chapeau bleu, blanc ou rouge, qu'ils ne peuvent voir. Un bourreau procède alors comme suit: en partant du dernier prisonnier il demande "Quelle est la couleur de ton chapeau ?", et le prisonnier n'a le droit qu'à une réponse, qui doit être une couleur. A la fin, les prisonniers qui ont deviné la couleur de leur chapeau sont épargnés, les autres exécutés. Les prisonniers peuvent se concerter avant l'épreuve sur la stratégie à adopter. Quelle est la meilleure stratégie ?<br><br>Voici maintenant l'énoncé complètement formalisé. Un prisonnier est représenté par une fonction qui prend deux listes de couleurs (celles qu'il voit devant lui, celles qui ont été prononcées comme réponses derrière lui), et renvoie une couleur (sa réponse). Dans la liste des réponses précédentes, la réponse du dernier de la file est la dernière de la liste. Trouver une fonction <code>prisonniers</code> qui à un entier <code>n</code> associe une liste de <code>n</code> fonctions/prisonniers telle que le nombre de morts calculé par <code>(execution (prisonniers n))</code> soit le plus petit possible dans le pire cas. La fonction d'exécution est la suivante:<br><pre>type couleur = Bleu | Blanc | Rouge<br>type prisonnier = couleur list -&gt; couleur list -&gt; couleur<br><br>let random_couleur () =<br>  let n = Random.int 3 in<br>    if n = 0 then Bleu else if n = 1 then Blanc else Rouge<br><br>let execution (prisonniers : prisonnier list) =<br>  let prisonniers =<br>    List.map (fun p -&gt; p, random_couleur ()) prisonniers<br>  in<br>  let rec morts avant = function<br>    | (p,c)::l -&gt;<br>        let reponse = p (List.map snd l) avant in<br>          (if reponse = c then 0 else 1) +<br>          (morts (reponse::avant) l)<br>    | [] -&gt; 0<br>  in<br>    morts [] prisonniers</pre><br>Amusez-vous bien, et postez vos réponses dans le langage de votre choix...<br><br><b>Edit</b>: une autre énigme beaucoup plus étonnante, que Florent et Julien m'ont racontée. Vous avez devant vous sur une table 7 pièces côté pile et 19 pièces côté face. Mais vos yeux sont bandés (et vous portez des moufles) de sorte que vous ne pouvez savoir l'état d'une pièce. Tout ce que vous pouvez faire c'est en retourner certaines, autant que vous voulez, et les déplacer. Il vous faut les séparer en deux groupes qui contiennent le même nombre de pièces côté pile.<br><br>La solution sera une fonction qui prend le nombre de piles et le nombre de faces (je vous aide bien en généralisant) et qui renvoie deux tableaux de taille <code>piles+faces</code>: le premier indique les indices des pièces choisies, le second indique les pièces qu'il faut retourner. La fonction sera passée à la fonction de test suivantes:<br><pre>(** Perfect Fisher-Yates shuffle<br>  * (http://www.nist.gov/dads/HTML/fisherYatesShuffle.html). *)<br>let randomize a =<br>  let permute i j =<br>    let tmp = a.(i) in<br>      a.(i) &lt;- a.(j);<br>      a.(j) &lt;- tmp<br>  in<br>  let l = Array.length a in<br>    if l&gt;=2 then<br>      for i=0 to l-2 do<br>        permute i (i + Random.int (l-i))<br>      done<br><br>let test nb_piles nb_faces joueur =<br>  let choix,retourne = joueur nb_piles nb_faces in<br>  let n = nb_piles + nb_faces in<br>  let a = Array.init n (fun i -&gt; i&lt;nb_piles) in<br>  (* Nombre de piles à gauche - nombre de piles à droite *)<br>  let d = ref 0 in<br>    randomize a ;<br>    for i = 0 to n-1 do<br>      if retourne.(i) then a.(i) &lt;- not a.(i) ;<br>      d := (if choix.(i) then (+) else (-)) !d (if a.(i) then 1 else 0)<br>    done ;<br>    !d = 0</pre><br>A suivre: les solutions commentées...
