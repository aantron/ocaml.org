---
title: "Mise en bo\xEEte"
description:
url: https://misterpingouin.blogspot.com/2009/06/mise-en-boite.html
date: 2009-06-04T11:38:00-00:00
preview_image:
authors:
- mrpingouin
source:
---

Depuis un bon moment, liquidsoap dispose d'un langage de configuration/script fonctionnel, fortement et statiquement typé, qui infère des types à la ML, le tout à l'insu de la plupart des utilisateurs. Pour liquidsoap 1.0 nous irons plus loin dans l'utilisation de concepts avancés avec (un peu) de vrai polymorphisme.<br><br><em>J'ai <b>édité</b> ce post deux ou trois dans les jours suivant sa publication. Peut-être que le blog n'était pas le format idéal.</em><br><br><b>Pourquoi?</b><br><br>Dans une conf liquidsoap, les fonctions sont parfois utiles pour éviter de recopier du code, ou pour spécifier une action à effectuer en réaction à certains évenements. Mais au coeur même de la génération du flux, les fonctions sont utilisées pour représenter les transitions entre pistes audio. (Détails <a href="http://www.lix.polytechnique.fr/~dbaelde/productions/pool/jfla08.pdf">ici</a>.)<br><br>Cette même notion de transition pose des problèmes quant à l'écoulement du temps. Actuellement dans liquidsoap, toutes les sources de flux audio évoluent à la même vitesse, cadencées par une unique horloge. Pour calculer une transition entre deux pistes d'une même source, l'opérateur <code>cross</code> doit obtenir en avance le début de la piste suivante, et le combiner avec la fin de la piste en cours. Cela requiert d'accélérer cette source.<br><br>L'implémentation actuelle n'est pas une solution: Les opérateurs qui en ont besoin simulent l'action de l'horloge auprès de leur source, afin de l'accélérer. Cela marche souvent, mais il se peut que deux opérateurs lisent une même source à des vitesses différentes. Le résultat est inattendu, à éviter. Notre mission est d'éviter cela statiquement, avant même la construction des sources. Nous allons donc attacher un paramètre au type des sources, qui représentera son horloge, et spécifier dans le type des opérateurs s'ils requièrent des horloges particulières.<br><br>S'il est assez facile de bricoler le système de type pour obtenir l'effet désiré, il faut d'abord identifier les concepts "logiques" mis en jeux. J'ai honte, mais ça m'a pris du temps, car j'ai <a href="http://savonet.rastageeks.org/wiki/FutureBoxes">commencé</a> par chercher dans des contrées exotiques alors que c'est assez connu, bien que pointu.<br><br><b>Polymorphisme</b><br><br>Le polymorphisme est la possibilité de former une quantification universelle sur les types. Si on a un objet de type <code>∀x. x-&gt;x</code>, on peut l'instantier en une fonction de type <code>int-&gt;int</code> aussi bien que <code>(bool-&gt;bool)-&gt;(bool-&gt;bool)</code>.<br><br>Dans les langages dérivés de ML, le polymorphisme est limité à une quantification externe. On peut avoir <code>∀x. x-&gt;x</code> mais pas <code>(∀x. x-&gt;x)-&gt;int-&gt;int</code>. Le polymorphisme dans toute sa généralité, par exemple dans le système F, rend en effet l'inférence de type indécidable.<br><br>OCaml permet cependant d'aller un peu plus loin. La clé est que la création d'un type polymorphe doit être explicite dans le programme (cf. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.4858">ce papier</a>), par exemple associée à la création d'un enregistrement. Considérons la signature suivante:<br><div class="code">(** Une source associée à l'horloge 'a *)<br>type 'a src<br><br>(** Une fonction qui renvoie une source qu'on peut<br>  * associer à n'importe quelle horloge. *)<br>type boxed = { c : 'a. unit -&gt; 'a src }<br><br>(** Cet opérateur prend une source en boîte,<br>  * cela pourrait être le cross() de liquidsoap. *)<br>val box  : boxed -&gt; 'a src<br><br>val leaf : unit -&gt; 'a src            (* en gros, single *)<br>val node : 'a src list -&gt; 'a src     (* en gros, fallback *)<br></div><br><br>Voyons voir ce qu'on peut et ne peut pas faire avec ce système. On peut créer un certain nombre de sources avec <code>leaf ()</code> initialement, elles auront le type <code>'_a src</code>: leur horloge est indéfinie, mais pas généralisable. On est content de ne pas voir de <code>'a src</code>: cela correspondrait à une source qui peut se brancher sur toutes les horloges <em>à la fois</em>, non-sens. (C'est aussi pour cela qu'on n'a pas écrit <code>boxed = { c : 'a. 'a src }</code>, on n'aurait jamais pu construire de boîte.)<br><br>On peut passer une source de type <code>'_a src</code> à notre opérateur <code>node</code>, on obtient une autre source à la même horloge <code>'_a</code>. Si on passe deux sources à <code>node</code>, le système de type requiert que leurs horloges soient les mêmes (des inconnues <code>'_a</code> et <code>'_b</code> sont unifiées).<br><br>Maintenant, tentons de former des boîtes:<br><div class="code">let b = box { c = leaf }<br>(* Gagné:<br> * une boîte qui nous donne une nouvelle feuille à chaque fois,<br> * horloge au choix. *)<br><br>let a = leaf ()<br>let b = box { c = fun () -&gt; b }<br>(* Raté, erreur de type:<br> * la source a est de type '_a src,<br> * la fonction (fun () -&gt; b) est de type unit -&gt; '_a src,<br> * qu'on ne peut généraliser en 'a. unit -&gt; 'a src. *)<br><br>let b =<br>  box { c = fun () -&gt;<br>              let a = leaf () in<br>                 node [a;a] }<br>(* Gagné, on a une boîte qui nous renvoie une source composée,<br> * dont on peut choisir l'horloge. *)<br></div><br><br>On tient clairement le bon concept: le polymorphisme assure que l'horloge peut être choisie. En particulier on va pouvoir créer des nouvelles horloges dédiées à certaines sources (et leurs sous-sources). Reste à transférer ce petit exemple en quelquechose d'agréable à utiliser dans liquidsoap.<br><br><b>Liquidsoap 1.0</b><br><br>Actuellement dans liquidsoap, on écrit des choses comme:<br><div class="code">music = playlist("list.txt")<br>backup = single("default.ogg")<br>source = fallback([music,backup])<br>transition = fun (a,b) -&gt; ...<br>source = cross(transition,source)<br>output.icecast(source)<br></div><br><br>En collant au style de notre exemple en OCaml, nous devrions réécrire les choses ainsi:<br><div class="code">transition = fun (a,b) -&gt; ...<br>source =<br>  cross(transition, {<br>    music = playlist("list.txt")<br>    backup = single("default.ogg")<br>    fallback([music,backup])<br>  })<br>output.icecast(source)<br></div><br><br>C'est trop lourd, et ma solution ne va différer que d'un epsilon du style courant:<br><div class="code">music = playlist("list.txt")<br>backup = single("default.ogg")<br>source = fallback([music,backup])<br>transition = fun (a,b) -&gt; ...<br>source = cross(transition,{source})<br>output.icecast(source)<br></div><br><br>Un point clé qui permet cette simplification est qu'on n'a besoin que d'une partie du polymorphisme: on veut la généricité, mais une seule fois. Pas besoin d'une fonction qui à chaque appel pond une source, comme dans l'exemple en Caml. Il suffit d'une seule source, tant que son horloge est générique.<br><br>Je pense qu'on ne peut pas se passer aisément du marqueur <code>{source}</code> qui indique qu'on généralise cette source. Il me semble acceptable de demander à l'utilisateur de marquer le coup quand il utilise cette notion complexe. (Par contre il va nous falloir choisir une syntaxe qui ne rentre pas en conflit avec l'actuel <code>{...}</code>, raccourci pour <code>fun () -&gt; ...</code>.)<br><br><b>Comment ça marche</b><br><br>J'ai une <a href="http://www.lix.polytechnique.fr/~dbaelde/productions/pool/boxes.ml.html">implémentation</a> en OCaml qui me semble transposable à liquidsoap.<br><br>Comment OCaml vérifie-t-il que <code>{ c = fun () -&gt; blah }</code> est bien typé? Il introduit une nouvelle variable de type <code>n</code> pour représenter le <code>'a</code> de <code>'a. unit -&gt; 'a src</code>, et vérifie qu'on peut donner le type <code>n src</code> à <code>blah</code>.<br><br>Nous allons faire la même chose, mais dans le désordre, pour permettre le genre d'écriture promis plus haut. Pour former une boîte (un type universel) sur une source, il faut que son horloge soit encore indéterminée. On vérifie cela en unifiant le type de cette source avec <code>n src</code> pour une nouvelle variable de type <code>n</code> comme OCaml faisait. Et une fois qu'on a ainsi réussit à former une boîte, on affecte cette variable à type à une valeur interdite <code>Boom</code> pour empêcher son utilisation ailleurs. Au lieu de créer les sources dans une zone protégée, on les crée en dehors, et on les y affecte après coup, ce qui rend alors leur horloge dénuée de sens à l'extérieur.<br><br>Un difficulté essentielle du polymorphisme vient du fait que pour inférer, on a besoin de savoir quel type universel on forme. Dans le cas de liquidsoap ma solution est très simple: on ne forme que <code>∀x. x src</code>. On pourrait avoir d'autres types polymorphes, mais chacun aurait son constructeur particulier.<br><br>Ces mécanismes fonctionnent bien sur quelques exemples disponibles dans mon code:<br><div class="code">ex0 = single ()<br>ex0 : '_a src   # pas de généralisation, c'est comme avec ref<br><br>ex00 = let x = single () in {x}<br>ex00 : 'a. 'a src<br><br>ex1 = fun (x) -&gt; cross(x)<br>ex1 : 'b. ('a. 'a src) -&gt; 'b src<br><br>ex4 = fun (_) -&gt; cross({single("blah.ogg")})<br>ex4 : 'a.'b. 'a -&gt; 'b src<br></div><br><br>Un exemple plus subtil est <code>ex2 = fun (x) -&gt; {x}</code>, ou la variation <code>ex4 = fun (x) -&gt; cross({x})</code> qui se rapproche de <code>ex1</code>. Ici une boîte est formée sur l'argument de la fonction, qui doit donc être une source. Ce genre de construction est problématique: la source doit être introduite avant son horloge. En pratique, cela se traduit par l'impossibilité de former le type de la fonction où devrait apparaitre le symbole interdit: <code>Boom src -&gt; 'a. 'a src</code>.
